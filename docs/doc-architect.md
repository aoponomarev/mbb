# Архитектурный план

> Оглавление `docs/doc-architect.md`
- § Технологический стек
  - *Среда исполнения* — развёртывание на GitHub Pages, фронтенд без серверного кода.
  - *Фреймворки и UI* — Vue.js + Bootstrap, приоритет Bootstrap-классов.
  - *Работа фронтенда* — размещение компонентов в `#app`, порядок загрузки запросов.
  - *Перенос кода из первоисточников и старых версий* — правила сохранения имён, семантики, комментариев.
- § Маркировка элементов DOM
  - *Автоматическая маркировка контейнеров* — система автоматической маркировки через классы `avto-{hash}`.
  - *Детерминированные хэши компонентов* — `instanceHash` для экземпляров Vue-компонентов.
  - *MutationObserver* — автоматическая маркировка асинхронно загружаемых элементов.
- § Технические ограничения
  - *Порядок загрузки x-template шаблонов* — критический порядок загрузки шаблонов до Vue.js.
  - *Размещение компонентов* — все Vue-компоненты внутри `<div id="app">`.
  - *Внешние запросы* — запрет запросов вне `#app` до разблокировки сплэш-экрана.
- § Принципы модульности
  - *Роль index.html* — точка подключения скриптов и стилей.
  - *Вынос x-template шаблонов* — шаблоны встроены в `core/templates-inline.js`.
  - *Модульная система загрузки скриптов* — реализована через `core/modules-config.js` и `core/module-loader.js`.
  - *Группировка компонентов и модулей* — по функциональности, слоям, типу файлов, декомпозиция компонентов.
  - *Правила размещения файлов* — структура папок для шаблонов, компонентов, стилей, утилит.
  - *Порядок загрузки* — последовательность загрузки стилей, скриптов, шаблонов, модулей.
  - *Принципы именования* — kebab-case для файлов компонентов, шаблонов, утилит.
  - *Работа без сборки* — поддержка GitHub Pages и `file://` без bundler'ов.
- § Принципы кэширования
  - *Архитектура кэширования* — разделение на слои хранения, единый интерфейс, версионирование.
  - *Слои хранения* — hot (localStorage), warm/cold (IndexedDB) по объёму и частоте доступа.
  - *Стратегии кэширования* — cache-first, network-first, stale-while-revalidate, cache-only.
  - *Версионирование и миграции* — автоматические миграции при изменении структуры данных.
  - *Индексация и производительность* — индексы IndexedDB для быстрого поиска временных рядов.
  - *Очистка и квоты* — автоматическая очистка старых данных, политики хранения.
- § Критически важные структуры
  - *Валидация и схемы данных* — схемы для API-ответов, нормализация, проверка типов.
  - *Обработка ошибок* — единая система классификации, логирования, пользовательских сообщений.
  - *Rate limiting и адаптивные таймауты* — централизованное управление запросами к API.
  - *Система состояний загрузки* — единый подход к состояниям loading, error, success.
  - *Событийная система* — глобальная шина событий для коммуникации между компонентами.
  - *Валидация математических вычислений* — проверка корректности расчётов и диапазонов.
  - *Конфигурация приложения* — централизованная конфигурация API, лимитов, настроек.
  - *Логирование* — структурированное логирование с уровнями и контекстом.
- § Библиотеки и зависимости
  - *Приоритет библиотек* — использование библиотек перед кастомными модулями.
  - *Схема хранения библиотек* — GitHub Pages CDN с fallback на внешние CDN.
  - *Механизм загрузки* — автоматический fallback при недоступности источников.
- `docs/doc-components.md` — описание компонентов приложения, API, особенности реализации.

> § <br> ТЕХНОЛОГИЧЕСКИЙ СТЕК

## Среда исполнения
- Приложение развёрнуто на GitHub Pages: только фронтенд, без серверного кода, корректные относительные пути и загрузка ресурсов по HTTPS (без `content://`).

## Фреймворки и UI
- Основной стек: Vue.js + Bootstrap для стилизации.
- Приоритет Bootstrap‑классов и утилит; кастомный CSS, inline‑стили и `<style>`‑блоки использовать минимально.

## Работа фронтенда
- Внешние HTTP‑запросы не запускать вне `#app`, пока сплэш‑экран не разблокирован.
- Компоненты и разметка, управляемые Vue, должны располагаться внутри `<div id="app">`.

## Перенос кода из первоисточников и старых версий
- Сохранять имена, семантику переменных/функций, полезные комментарии.
- Избегать конфликтов имён, комментировать новые переменные и решения.
- При возникновении конфликтов имен переменных — сообщать пользователю с достаточной детализацией, предлагая варианты решения.
- При переносе кода из первоисточников (примеров кода из других проектов) использовать переменные первоисточников в приоритете.
- Переносить комментарии первоисточников с сохранением их сути и контекста, адаптируя при необходимости. Всегда комментировать переменные при их объявлении, указывая их назначение и семантику для понимания другим разработчиком или ИИ-агентом.

> § <br> МАРКИРОВКА ЭЛЕМЕНТОВ DOM

## Автоматическая маркировка контейнеров

**Назначение**: Автоматическая маркировка значимых контейнеров через CSS классы `avto-{hash}` для навигации в коде через DevTools и указания агенту места в разметке.

**Формат**: Префикс `avto-`, формат `avto-{Base58_8символов}`. Признак: класс начинается с `avto-` → чистый контейнер без JS/CSS зависимостей.

**Реализация**: Утилита `shared/utils/auto-markup.js` с использованием `MutationObserver` для автоматической маркировки элементов при загрузке и при добавлении новых элементов в DOM.

**Правила применения**:
1. **Маркируются автоматически**: основные секции (`<main>`, `<section>`, `<article>`, `<aside>`, `<header>`, `<footer>`, `<nav>`), заголовки (`<h1>`–`<h6>`), корневые `.container`, `.container-fluid`, функциональные блоки (`.card`, `.card-body`, `.card-header`, `.card-footer`), элементы с атрибутом `data-markup`
2. **НЕ маркируются**: элементы внутри Vue компонентов (у них уже есть `instanceHash`), мелкие обертки без функционального значения (`.row`, `.col-*`), элементы с `data-no-markup`, элементы с ID (JS-зависимые элементы), служебные элементы (`<script>`, `<style>`, `<noscript>`)

**Исключения**:
- Элементы внутри Vue компонентов пропускаются (у них уже есть `instanceHash` через computed свойство)
- Элементы с `data-no-markup` пропускаются
- Элементы с ID пропускаются (JS-зависимые элементы)

**Инициализация**: Автоматически инициализируется после монтирования Vue приложения через `window.autoMarkup.init()` в `app/app-ui-root.js`.

**Ручной вызов**: `window.autoMarkup.markupContainer(element)` для маркировки конкретного контейнера после асинхронной загрузки.

**Детерминированность**: Хэш генерируется на основе пути элемента в DOM (tagName, позиция среди siblings, классы), что обеспечивает стабильность между сессиями для статичных элементов.

## Детерминированные хэши компонентов

**Назначение**: Уникальная идентификация экземпляров Vue-компонентов для возможности кастомной стилизации конкретных экземпляров.

**Реализация**: Computed свойство `instanceHash` в каждом компоненте, которое генерирует детерминированный Base58 хэш на основе:
- Родительского контекста (класс `avto-*` или ID родителя)
- Идентификатора экземпляра из props (`buttonId`, `itemId`, `dropdownId` или fallback на `label`, `title`, `icon`)

**Формат**: `avto-{Base58_8символов}` (тот же формат, что и для контейнеров).

**Применение**: Хэш автоматически добавляется к корневому элементу компонента через computed свойство в `buttonClasses`, `itemClasses` и т.д.

**Стабильность**: Один и тот же контекст + идентификатор всегда дает один и тот же хэш, что обеспечивает стабильность между сессиями.

**Утилита**: `shared/utils/hash-generator.js` — генерация детерминированных Base58 хэшей из строк.

> § <br> ТЕХНИЧЕСКИЕ ОГРАНИЧЕНИЯ

## Порядок загрузки x-template шаблонов
При использовании `<script type="text/x-template">` для Vue компонентов — шаблон **ОБЯЗАТЕЛЬНО** должен быть в DOM **ДО** загрузки Vue.js и компонентов, которые его используют. Правильный порядок в `index.html`: 1) Bootstrap JS, 2) x-template шаблоны, 3) Vue.js, 4) компоненты, 5) app-ui-root.js. Нарушение порядка приводит к тому, что Vue не находит шаблон при монтировании компонента, и компонент не отображается.

## Размещение компонентов
Vue-монтирует только то, что находится в пределах `#app`, поэтому сплэш-экраны, модалки, новые UI-блоки и контейнеры должны рендериться внутри `<div id="app">`.

## Внешние запросы
Не запускать внешние HTTP-запросы (CoinGecko, CDN и т.п.) или иные операции вне `#app`, пока сплэш-экран не разблокирован.

> § <br> ПРИНЦИПЫ МОДУЛЬНОСТИ

## Роль index.html
`index.html` служит только точкой подключения всех скриптов и стилей. Вся разметка компонентов, шаблоны и логика вынесены в отдельные модули.

## Вынос x-template шаблонов
- Шаблоны компонентов хранятся в `core/templates-inline.js` как строки JavaScript
- Формат: шаблоны встроены в объект `TEMPLATES` и вставляются в DOM при загрузке файла
- Загрузка: `core/templates-inline.js` загружается через обычный `<script>` тег ДО инициализации Vue.js
- Шаблоны вставляются в DOM как `<script type="text/x-template">` элементы автоматически
- **Преимущество**: работает с `file://` протоколом (не требует fetch/XMLHttpRequest)
- **Примечание**: Структура `shared/templates/` и `features/<feature-name>/templates/` зарезервирована на будущее для динамической загрузки шаблонов

## Модульная система загрузки скриптов
**Статус**: Реализована.

**Реализация:**
- Конфигурационный файл `core/modules-config.js` описывает все модули и их зависимости
- Модули группируются по категориям: `utilities`, `core`, `templates`, `libraries`, `components`, `app`
- Загрузчик модулей `core/module-loader.js` читает конфигурацию и загружает модули в правильном порядке
- Автоматическое разрешение зависимостей через топологическую сортировку (алгоритм Kahn)
- Обнаружение циклических зависимостей
- Поддержка работы с `file://` и `http://` протоколами через асинхронную загрузку `<script>` тегов
- В `index.html` остаётся только подключение конфигурации и загрузчика модулей

**Структура конфигурации:**
- Каждый модуль описывается объектом с полями: `id`, `src`, `type` (`local` | `external`), `deps` (массив ID зависимостей), `category`
- Зависимости указываются через ID модулей
- Загрузчик автоматически определяет правильный порядок загрузки на основе зависимостей

**Преимущества:**
- Централизованное управление зависимостями
- Автоматическая проверка порядка загрузки
- Легко добавлять/удалять модули
- Поддержка `file://` и `http://` протоколов
- Детальные сообщения об ошибках
- Кэширование загруженных модулей (избежание повторной загрузки)
- Улучшенная обработка ошибок (критичные модули прерывают загрузку, некритичные продолжают)
- Условная загрузка модулей через feature flags (опциональное поле `condition`)

**Дополнительные возможности:**
- Кэширование: модули кэшируются после загрузки, повторная загрузка не выполняется
- Обработка ошибок: критичные модули (app, vue, templates-inline) при ошибке прерывают загрузку; некритичные модули пропускаются с предупреждением
- Feature flags: каждый модуль может иметь опциональное поле `condition` (функция), которая определяет, нужно ли загружать модуль

## Группировка компонентов и модулей
- По функциональности (`features/`): **зарезервировано на будущее** — markets, settings, layout (каждая feature будет содержать компоненты, утилиты, шаблоны, стили, конфигурацию)
- По слоям архитектуры: `core/` (базовые утилиты), `domain/` (бизнес-логика), `shared/` (переиспользуемые компоненты), `app/` (корневой компонент)
- По типу файлов: `shared/components/` (переиспользуемые Vue компоненты), `app/styles/` (общие CSS), `core/api/` (API-утилиты), `features/*/components/` (feature-specific компоненты — зарезервировано)
- Разделение shared/feature-specific: `shared/` — переиспользуемые компоненты (button, dropdown, dropdown-menu-item, combobox), утилиты (pluralize, hash-generator, auto-markup). `app/styles/` — общие стили (responsive-breakpoints). `features/` — зарезервировано на будущее для feature-specific компонентов и утилит.

## Правила размещения файлов
- Шаблоны: встроены в `core/templates-inline.js` (текущая реализация). Структура `shared/templates/` и `features/<feature-name>/templates/` зарезервирована на будущее для динамической загрузки
- Компоненты Vue: `shared/components/<component-name>.js` (переиспользуемые) или `features/<feature-name>/components/<component-name>.js` (feature-specific — зарезервировано)
- Стили: `app/styles/<component-name>.css` (общие) или `features/<feature-name>/styles/<component-name>.css` (feature-specific — зарезервировано)
- Утилиты: `shared/utils/<utility-name>.js` (общие) или `features/<feature-name>/utils/<utility-name>.js` (feature-specific — зарезервировано)
- Конфигурация: `shared/config/<config-name>.js` (общая) или `features/<feature-name>/config/<config-name>.js` (feature-specific — зарезервировано)
- Утилиты API: `core/api/<api-name>.js` (чистые функции, не Vue)
- Математические модели: `mm/<model-name>/utils/`, `mm/<model-name>/core/`, `mm/<model-name>/metrics/`

## Порядок загрузки
1. Bootstrap CSS и внешние стили
2. Локальные стили (`app/styles/responsive-breakpoints.css`)
3. Font Awesome 6 и Material Symbols
4. Bootstrap JS
5. Модульная система загрузки:
   - `core/modules-config.js` — конфигурация модулей
   - `core/module-loader.js` — загрузчик модулей
   - Автоматическая загрузка всех модулей в правильном порядке:
     - Утилиты (`utilities`): hash-generator, auto-markup, pluralize
     - Core модули (`core`): cache, validation, errors, api, config, events, state, logging (в порядке зависимостей)
     - Шаблоны (`templates`): templates-inline
     - Библиотеки (`libraries`): vue
     - Компоненты (`components`): dropdown-menu-item, button, dropdown, combobox
     - Приложение (`app`): app-ui-root

**Порядок загрузки модулей определяется автоматически** на основе зависимостей, описанных в `core/modules-config.js`. Загрузчик использует топологическую сортировку для определения правильной последовательности.

**Пример порядка загрузки** (автоматически определяется):
1. Утилиты без зависимостей (hash-generator, pluralize)
2. Core модули без зависимостей (storage-layers, cache-config, validation-schemas, и т.д.)
3. Core модули с зависимостями (cache-manager зависит от storage-layers, cache-config, cache-migrations)
4. Шаблоны (templates-inline)
5. Auto-markup (зависит от hash-generator)
6. Vue.js (зависит от templates-inline)
7. Компоненты (зависят от vue и утилит)
8. Приложение (app-ui-root зависит от всех компонентов)

## Принципы именования
- Файлы компонентов: kebab-case (`button.js`, `system-messages.js` и т.д.)
- Файлы шаблонов: kebab-case с суффиксом `-template` (`button-template.html` и т.п.)
- Файлы утилит: kebab-case (`coingecko.js`, `table-sort-mixin.js` и т.д.)
- ID шаблонов в DOM: kebab-case (соответствует имени файла без расширения)
- Файлы документации: префикс `doc-` (`doc-architect.md` и т.п.)
- Файлы тематических логов: префикс `log-` (файлы в папке `docs/logs/`)

## Работа без сборки
Проект должен работать на GitHub Pages (HTTPS) и локально через `file://` протокол без использования bundler'ов. Ограничения: нет ES6 модулей (import/export), использование глобальных переменных через `window.*`, динамическая загрузка через `fetch()` и создание `<script>` тегов, относительные пути к файлам.

> § <br> ПРИНЦИПЫ КЭШИРОВАНИЯ

## Архитектура кэширования
Единая система кэширования через `core/cache/cache-manager.js` обеспечивает абстракцию над хранилищами (localStorage, IndexedDB), версионирование данных, автоматические миграции и стратегии кэширования. Все компоненты работают с кэшем через единый интерфейс, что позволяет менять реализацию без изменения кода компонентов.

## Слои хранения
- **Hot (localStorage)**: небольшие данные (< 5MB), частый доступ — настройки, избранное, UI-состояние, иконки монет
- **Warm (IndexedDB)**: средний объём (5–50MB), частый доступ — список монет, метрики рынка, кэш API-ответов
- **Cold (IndexedDB)**: большие объёмы (50MB+), редкий доступ — временные ряды, история портфелей, стратегии, корреляции

## Стратегии кэширования
- **cache-first**: иконки, список монет — всегда из кэша, обновление в фоне
- **network-first**: метрики рынка, цены — сначала сеть, fallback на кэш
- **stale-while-revalidate**: временные ряды, история — показываем кэш, обновляем в фоне
- **cache-only**: портфели пользователя, стратегии — только локальные данные

## Версионирование и миграции
Каждая запись в кэше содержит версию схемы данных. При изменении структуры данных (например, `archivedCoins` из массива строк в объекты) автоматически запускаются миграции из `core/cache/cache-migrations.js`. Это обеспечивает совместимость при обновлении приложения и предотвращает потерю данных пользователей.

## Индексация и производительность
IndexedDB использует индексы для быстрого поиска: временные ряды индексируются по `coinId` и `timestamp`, портфели — по `userId` и `createdAt`, стратегии — по `type` и `isActive`. Индексы определяются в `core/cache/cache-indexes.js` при инициализации хранилища.

## Очистка и квоты
Автоматическая очистка старых данных по политикам из `core/cache/cache-cleanup.js`: временные ряды старше 90 дней сжимаются (1 точка в час), история портфелей старше 1 года архивируется. При достижении квот хранилища запускается приоритетная очистка (сначала cold, затем warm, hot очищается только при критическом переполнении).

> § <br> КРИТИЧЕСКИ ВАЖНЫЕ СТРУКТУРЫ

## Валидация и схемы данных
Схемы валидации в `core/validation/schemas.js` определяют структуру и типы данных для API-ответов (CoinGecko, метрики рынка), временных рядов, портфелей и стратегий. Валидация выполняется через `core/validation/validator.js` перед использованием данных в расчётах. Нормализация данных в `core/validation/normalizer.js` приводит данные к единому формату независимо от источника. Это предотвращает ошибки в математических моделях из-за некорректных данных.

## Обработка ошибок
Единая система обработки ошибок в `core/errors/error-handler.js` классифицирует ошибки (API, валидация, вычисления, сеть), логирует их через `core/logging/logger.js`, показывает пользовательские сообщения и выполняет автоматические повторные попытки с fallback-стратегиями. Классы ошибок в `core/errors/error-types.js` определяют типы ошибок и их обработку. Это обеспечивает предсказуемое поведение при ошибках и упрощает отладку.

## Rate limiting и адаптивные таймауты
Централизованное управление запросами к API через `core/api/rate-limiter.js`: адаптивные таймауты (увеличение при 429 ошибках, уменьшение при успешных запросах), очередь запросов с приоритизацией, обработка rate limiting для всех внешних API. Базовые параметры и стратегии определяются в `core/config/api-config.js`. Это предотвращает блокировку API при массовых операциях и обеспечивает стабильную работу.

## Система состояний загрузки
Единый подход к состояниям загрузки через `core/state/loading-state.js`: управление состояниями (loading, error, success), индикаторы прогресса, обработка множественных загрузок, отмена запросов. Компоненты используют `window.loadingState` для синхронизации состояний. Это предотвращает конфликты состояний и обеспечивает единообразный UX.

## Событийная система
Глобальная шина событий в `core/events/event-bus.js` обеспечивает коммуникацию между компонентами без жёстких зависимостей. События: `data-updated`, `portfolio-changed`, `error-occurred`, `cache-invalidated`. Компоненты подписываются через `window.eventBus.on()` и эмитят через `window.eventBus.emit()`. Это позволяет компонентам синхронизироваться при изменении данных без дублирования логики.

## Валидация математических вычислений
Проверка корректности расчётов через `core/validation/math-validation.js`: проверка диапазонов значений (веса портфеля: сумма = 1, корреляции: -1 до 1), валидация метрик (не NaN, не Infinity), проверка временных рядов (монотонность времени, отсутствие пропусков). Это предотвращает ошибки в финансовых расчётах и обеспечивает корректность результатов.

## Конфигурация приложения
Централизованная конфигурация в `core/config/app-config.js`: API endpoints, лимиты и таймауты, настройки по умолчанию, версия приложения, feature flags. Конфигурация загружается при инициализации и доступна через `window.appConfig`. Это упрощает изменение настроек и тестирование различных конфигураций.

## Логирование
Структурированное логирование через `core/logging/logger.js` с уровнями (debug, info, warn, error) и контекстом (компонент, действие). Логи форматируются единообразно и могут быть отправлены на сервер для мониторинга (если понадобится). Это упрощает отладку финансовых расчётов и поиск проблем в production.

> § <br> БИБЛИОТЕКИ И ЗАВИСИМОСТИ

## Приоритет библиотек
Перед написанием кастомного модуля **обязательно** проверь наличие подходящих Vue-библиотек с расширяемым API. Приоритет библиотекам, которые имеют плагины, composables, возможность кастомизации. Кастомные модули создаются только если библиотека не существует, слишком тяжёлая или требуется специфичная бизнес-логика. Подробности в `docs/doc-lib-vue.md`.

## Схема хранения библиотек
Библиотеки хранятся в отдельном репозитории `https://github.com/aoponomarev/libs` и раздаются через GitHub Pages CDN по адресу `https://aoponomarev.github.io/libs/`. Структура: `lib-name/version/file.js`. Это обеспечивает контроль версий, единый репозиторий для всех проектов и простоту обновления библиотек.

## Механизм загрузки
Загрузка библиотек через `core/lib-loader.js` с автоматическим fallback: 1) GitHub Pages CDN (`https://aoponomarev.github.io/libs/`) — основной источник, 2) внешние CDN (jsdelivr, cdnjs) — fallback при недоступности, 3) локальное хранение (`./libs/`) — для критичных библиотек. Это обеспечивает надёжность загрузки даже при недоступности отдельных источников.

