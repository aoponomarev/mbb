# Архитектурный план

> Оглавление `docs/doc-architect.md`
- § Технологический стек
  - *Среда исполнения* — развёртывание на GitHub Pages, фронтенд без серверного кода.
  - *Фреймворки и UI* — Vue.js + Bootstrap, приоритет Bootstrap-классов.
  - *Работа фронтенда* — размещение компонентов в `#app`, порядок загрузки запросов.
  - *Перенос кода из первоисточников и старых версий* — правила сохранения имён, семантики, комментариев.
- § Единый источник правды
  - *Принцип единого источника правды* — обязательное требование для всех изменений в проекте.
  - *Конфигурационные файлы* — централизация значений в `core/config/` и `core/cache/`.
  - *Переиспользуемые компоненты* — устранение дублирования разметки и логики.
- § Маркировка элементов DOM
  - *Автоматическая маркировка контейнеров* — система автоматической маркировки через классы `avto-{hash}`.
  - *Детерминированные хэши компонентов* — `instanceHash` для экземпляров Vue-компонентов.
  - *MutationObserver* — автоматическая маркировка асинхронно загружаемых элементов.
  - *Утилита синхронизации layout* — автоматическая синхронизация padding body с высотой header/footer.
  - *Версионирование приложения* — CSS-класс версии на body, версионирование ключей кэша, автоматическая очистка старых версий.
- § Технические ограничения
  - *Порядок загрузки x-template шаблонов* — критический порядок загрузки шаблонов до Vue.js.
  - *Размещение компонентов* — все Vue-компоненты внутри `⟨div id="app"⟩`.
  - *Внешние запросы* — запрет запросов вне `#app` до разблокировки сплэш-экрана.
- § Принципы модульности
  - *Роль index.html* — точка подключения скриптов и стилей.
  - *Вынос x-template шаблонов* — шаблоны хранятся в `shared/templates/` как отдельные файлы.
  - *Модульная система загрузки скриптов* — реализована через `core/modules-config.js` и `core/module-loader.js`.
  - *Классификация компонентов и стилей* — три типа: Bootstrap Wrappers, Layout Components, Custom Components.
  - *Группировка компонентов и модулей* — по функциональности, слоям, типу файлов, декомпозиция компонентов.
  - *Правила размещения файлов* — структура папок для шаблонов, компонентов, стилей, утилит.
  - *Порядок загрузки* — последовательность загрузки стилей, скриптов, шаблонов, модулей.
  - *Принципы именования* — kebab-case для файлов компонентов, шаблонов, утилит.
  - *Работа без сборки* — поддержка GitHub Pages и `file://` без bundler'ов.
- § Принципы кэширования
  - *Архитектура кэширования* — разделение на слои хранения, единый интерфейс, версионирование.
  - *Слои хранения* — hot (localStorage), warm/cold (IndexedDB) по объёму и частоте доступа.
  - *Стратегии кэширования* — cache-first, network-first, stale-while-revalidate, cache-only.
  - *Версионирование данных* — автоматические миграции при изменении структуры данных.
  - *Версионирование приложения* — префикс версии для ключей кэша, автоматическая инвалидация при смене версии.
  - *Индексация и производительность* — индексы IndexedDB для быстрого поиска временных рядов.
  - *Очистка и квоты* — автоматическая очистка старых данных, политики хранения.
- § Критически важные структуры
  - *Валидация и схемы данных* — схемы для API-ответов, нормализация, проверка типов.
  - *Обработка ошибок* — единая система классификации, логирования, пользовательских сообщений.
  - *Rate limiting и адаптивные таймауты* — централизованное управление запросами к API.
  - *Система состояний загрузки* — единый подход к состояниям loading, error, success.
  - *Событийная система* — глобальная шина событий для коммуникации между компонентами.
  - *Валидация математических вычислений* — проверка корректности расчётов и диапазонов.
  - *Конфигурация приложения* — централизованная конфигурация API, лимитов, настроек.
  - *Логирование* — структурированное логирование с уровнями и контекстом.
  - *Система управления кнопками модального окна* — единая система управления кнопками в header и footer через provide/inject.
  - *Конфигурация модальных окон* — единый источник правды для заголовков, иконок и метаданных модальных окон через `core/config/modals-config.js`.
  - *Perplexity AI интеграция* — модуль для работы с Perplexity Chat Completions API, ленивая загрузка новостей, очистка артефактов.
  - *Синхронизация данных между компонентами* — паттерн синхронизации данных (таймзона, язык перевода) между app-ui-root, app-footer и модальными окнами.
- § Библиотеки и зависимости
  - *Приоритет библиотек* — использование библиотек перед кастомными модулями.
  - *Схема хранения библиотек* — GitHub Pages CDN с fallback на внешние CDN.
  - *Механизм загрузки* — автоматический fallback при недоступности источников.
- `docs/doc-components.md` — навигация и краткие описания компонентов приложения.
- `docs/doc-comp-principles.md` — принципы работы с компонентами, использование Bootstrap.
- `docs/doc-comp-classes.md` — механизм управления CSS классами.
- `docs/doc-comp-implementation.md` — практические аспекты реализации Vue-компонентов.

> § <br> ТЕХНОЛОГИЧЕСКИЙ СТЕК

## Среда исполнения
- Приложение развёрнуто на GitHub Pages: только фронтенд, без серверного кода, корректные относительные пути и загрузка ресурсов по HTTPS (без `content://`).

## Фреймворки и UI
- Основной стек: Vue.js + Bootstrap для стилизации.
- Приоритет Bootstrap‑классов и утилит; кастомный CSS, inline‑стили и `⟨style⟩`‑блоки использовать минимально.

## Работа фронтенда
- Внешние HTTP‑запросы не запускать вне `#app`, пока сплэш‑экран не разблокирован.
- Компоненты и разметка, управляемые Vue, должны располагаться внутри `⟨div id="app"⟩`.

## Перенос кода из первоисточников и старых версий
- Сохранять имена, семантику переменных/функций, полезные комментарии.
- Избегать конфликтов имён, комментировать новые переменные и решения.
- При возникновении конфликтов имен переменных — сообщать пользователю с достаточной детализацией, предлагая варианты решения.
- При переносе кода из первоисточников (примеров кода из других проектов) использовать переменные первоисточников в приоритете.
- Переносить комментарии первоисточников с сохранением их сути и контекста, адаптируя при необходимости. Всегда комментировать переменные при их объявлении, указывая их назначение и семантику для понимания другим разработчиком или ИИ-агентом.

> § <br> ЕДИНЫЙ ИСТОЧНИК ПРАВДЫ

**КРИТИЧЕСКИ ВАЖНО:** Принцип единого источника правды (Single Source of Truth) является обязательным требованием для всех изменений в проекте. Нарушение этого принципа недопустимо.

## Принцип единого источника правды

При наличии дублирующихся значений (заголовки, тексты, конфигурации, настройки) в нескольких местах необходимо использовать единый источник правды — конфигурационные файлы в `core/config/` и `core/cache/` или переиспользуемые компоненты. Это гарантирует единообразие, упрощает поддержку и устраняет риск рассинхронизации.

## Конфигурационные файлы

Все конфигурационные данные централизованы в следующих файлах:
- **`core/config/modals-config.js`** — заголовки, иконки, метаданные модальных окон
- **`core/cache/cache-config.js`** — TTL, версии схем, стратегии кэширования (включая TTL для новостей, обновления метрик)
- **`core/config/app-config.js`** — API endpoints, лимиты, таймауты, feature flags
- **`core/modules-config.js`** — порядок загрузки, зависимости модулей

**Примеры централизации:**
- TTL для кэша новостей (`crypto-news-cache-max-age`) вынесен из `app-footer.js` в `cache-config.js`
- TTL для fallback обновления метрик (`market-update-fallback`) вынесен из `app-footer.js` в `cache-config.js`
- TTL для максимальной задержки обновления (`market-update-delay-max`) вынесен из `app-footer.js` в `cache-config.js`
- Дефолтная таймзона (`defaults.timezone`) вынесена из `app-footer.js` и `perplexity-settings.js` в `app-config.js`
- Дефолтный язык перевода (`defaults.translationLanguage`) вынесен из `app-footer.js` в `app-config.js`
- Дефолтная модель Perplexity (`defaults.perplexity.model`) и список моделей (`defaults.perplexity.models`) вынесены из `app-footer.js` и `perplexity-settings.js` в `app-config.js`
- Времена обновления метрик (`defaults.marketUpdates.times`) вынесены из `app-footer.js` в `app-config.js`
- Маппинг аббревиатур таймзон (`defaults.timezoneAbbreviations`) и функция `getTimezoneAbbr()` вынесены из `app-footer.js` в `app-config.js`

## Правила работы с конфигурацией

1. **Всегда используйте функции-геттеры** из конфигурации вместо хардкода
2. **Не дублируйте значения** в разных местах — используйте конфигурацию
3. **Перед дублированием значения** проверяй наличие конфигурационного файла
4. **При необходимости создавай новые конфигурационные файлы** для централизации значений
5. **Статические примеры** должны использовать ту же конфигурацию, что и рабочие компоненты

## Переиспользуемые компоненты

Дублирующаяся разметка и логика выносятся в переиспользуемые компоненты в `shared/components/`. Подробности в `docs/doc-comp-principles.md` (раздел "Единый источник правды").

## ССЫЛКИ

- Принципы: `docs/doc-comp-principles.md` (раздел "Единый источник правды")
- Конфигурация модальных окон: `core/config/modals-config.js`
- Конфигурация кэширования: `core/cache/cache-config.js`
- Конфигурация приложения: `core/config/app-config.js`

> § <br> МАРКИРОВКА ЭЛЕМЕНТОВ DOM

## Автоматическая маркировка контейнеров

**Назначение**: Автоматическая маркировка значимых контейнеров через CSS классы `avto-{hash}` для навигации в коде через DevTools и указания агенту места в разметке.

**Формат**: Префикс `avto-`, формат `avto-{Base58_8символов}`. Классы `avto-*` используются только для маркировки, не используются в JS/CSS.

**Реализация**: Утилита `shared/utils/auto-markup.js` с использованием `MutationObserver` для автоматической маркировки элементов при загрузке и при добавлении новых элементов в DOM.

**Принципы**: Маркируются основные секции, заголовки, контейнеры; не маркируются элементы внутри Vue компонентов, мелкие обертки, элементы с ID. Детерминированные хэши на основе пути в DOM обеспечивают стабильность между сессиями.

**Инициализация**: Автоматически инициализируется после монтирования Vue приложения. Поддерживается ручной вызов для асинхронно загружаемых элементов.

**Детали реализации**: См. шапку файла `shared/utils/auto-markup.js`.

## Детерминированные хэши компонентов

**Назначение**: Уникальная идентификация экземпляров Vue-компонентов для возможности кастомной стилизации конкретных экземпляров.

**Реализация**: Computed свойство `instanceHash` в каждом компоненте, которое генерирует детерминированный Base58 хэш на основе:
- Родительского контекста (класс `avto-*` или ID родителя)
- Идентификатора экземпляра из props (`buttonId`, `itemId`, `dropdownId` или fallback на `label`, `title`, `icon`)

**Формат**: `avto-{Base58_8символов}` (тот же формат, что и для контейнеров).

**Применение**: Хэш автоматически добавляется к корневому элементу компонента через computed свойство в `buttonClasses`, `itemClasses` и т.д.

**Стабильность**: Один и тот же контекст + идентификатор всегда дает один и тот же хэш, что обеспечивает стабильность между сессиями.

**Утилита**: `shared/utils/hash-generator.js` — генерация детерминированных Base58 хэшей из строк.

## Версионирование приложения

**Назначение**: Привязка кэша и стилизации к версии приложения для автоматической инвалидации при обновлении.

**Реализация**:
- **CSS-класс на body**: `app-version-{hash}` — детерминированный Base58 хэш версии приложения (8 символов)
- **Версионирование ключей кэша**: префикс `v:{hash}:` для ключей, зависящих от структуры данных
- **Автоматическая очистка**: при инициализации приложения удаляются ключи старых версий

**Применение**:
- **Инвалидация кэша**: при смене версии автоматически очищаются ключи с префиксом старой версии
- **Версионная стилизация**: CSS-селекторы по версии (`.app-version-{hash} .element`)
- **Отладка**: видно версию приложения в DOM через класс на body
- **Стабильность**: хэш не меняется между рефрешами/сессиями, только при смене версии в `app-config.js`

**Версионируемые ключи кэша** (автоматически):
- `icons-cache` — иконки монет (структура CoinGecko API)
- `coins-list` — список монет (структура CoinGecko API)
- `api-cache` — кэш API-ответов (структура внешних API)
- `market-metrics` — метрики рынка (структура внешних API)
- `crypto-news-state` — состояние новостей (структура зависит от промпта Perplexity)

**Невersionируемые ключи** (пользовательские данные):
- `settings`, `theme`, `timezone`, `favorites`, `ui-state`
- `perplexity-api-key`, `perplexity-model`, `translation-language`
- `portfolios`, `strategies`, `time-series`, `history`

**Критерии применения версионирования кэша:**

**ВЕРСИОНИРОВАТЬ, если:**
- ✅ Данные из внешних API (CoinGecko, Perplexity, и т.д.) — структура может измениться
- ✅ Данные парсятся из ответов API — формат может измениться, старый кэш вызовет ошибки парсинга
- ✅ Структура данных зависит от версии приложения — изменения в коде могут изменить формат
- ✅ Данные кэшируются для производительности, но должны обновляться при обновлении приложения
- ✅ Ошибки в старых данных могут привести к сбоям приложения

**НЕ версионировать, если:**
- ❌ Пользовательские данные — должны сохраняться между обновлениями (`portfolios`, `strategies`, `time-series`, `history`)
- ❌ Настройки пользователя — пользователь не должен перенастраивать после каждого обновления (`theme`, `timezone`, `translation-language`, `perplexity-api-key`, `perplexity-model`)
- ❌ UI-состояние — должно сохраняться между обновлениями (`ui-state`, `favorites`, `active-tab`)
- ❌ Данные с миграциями — используют систему миграций схем (`cache-migrations.js`) вместо версионирования приложения

**Правило принятия решения:**
Если изменение структуры данных при обновлении приложения может вызвать ошибки парсинга или сбои, и данные не являются пользовательскими — версионировать. Если данные пользовательские или имеют систему миграций — не версионировать.

**Для агента при разработке новой функциональности:**
При добавлении нового ключа кэша:
1. Определить источник данных (внешний API / пользователь / приложение)
2. Оценить риск ошибок при изменении структуры
3. Если данные из внешнего API или парсятся — добавить в список версионируемых ключей
4. Если данные пользовательские — использовать миграции схем вместо версионирования приложения
5. При сомнениях — спросить пользователя или добавить в версионируемые (безопаснее)

**API**:
- `appConfig.getVersionHash()` — получить хэш версии (Base58, 8 символов)
- `appConfig.getVersionClass()` — получить CSS-класс версии (`app-version-{hash}`)
- `cacheManager.clearOldVersions()` — очистить кэш старых версий (возвращает количество удаленных ключей)
- `cacheManager.getVersionedKey(key, useVersioning)` — получить версионированный ключ

**Файлы**:
- Конфигурация версии: `core/config/app-config.js` (CONFIG.version)
- Установка класса на body: `app/app-ui-root.js` (initVueApp)
- Версионирование кэша: `core/cache/cache-manager.js` (getVersionedKey, clearOldVersions)
- Генерация хэша: `shared/utils/hash-generator.js`

## Утилита синхронизации layout

**Назначение**: Автоматическая синхронизация `padding-top` и `padding-bottom` body с высотой фиксированных header и footer для предотвращения перекрытия контента.

**Реализация**: Утилита `shared/utils/layout-sync.js` с использованием `ResizeObserver` (отслеживание изменений размеров) и `MutationObserver` (отслеживание изменений атрибутов, дочерних элементов, поддерева).

**Принципы**: Автоматически устанавливает padding на body на основе реальной высоты header и footer. Использует CSS переменные `--header-height` и `--footer-height` для нативного подхода. Поддерживает динамические изменения высоты header/footer (изменение размера кнопок, добавление/удаление элементов, изменение классов).

**Инициализация**: Автоматически запускается при загрузке DOM. Поддерживает ручное управление через `window.layoutSync.start()`, `stop()`, `update()`.

**Детали реализации**: См. шапку файла `shared/utils/layout-sync.js`.

> § <br> ТЕХНИЧЕСКИЕ ОГРАНИЧЕНИЯ

## Порядок загрузки x-template шаблонов
При использовании `⟨script type="text/x-template"⟩` для Vue компонентов — шаблон **ОБЯЗАТЕЛЬНО** должен быть в DOM **ДО** загрузки Vue.js и компонентов, которые его используют. Правильный порядок в `index.html`: 1) Bootstrap JS, 2) x-template шаблоны, 3) Vue.js, 4) компоненты, 5) app-ui-root.js. Нарушение порядка приводит к тому, что Vue не находит шаблон при монтировании компонента, и компонент не отображается.

## Размещение компонентов
Vue-монтирует только то, что находится в пределах `#app`, поэтому сплэш-экраны, модалки, новые UI-блоки и контейнеры должны рендериться внутри `⟨div id="app"⟩`.

## Внешние запросы
Не запускать внешние HTTP-запросы (CoinGecko, CDN и т.п.) или иные операции вне `#app`, пока сплэш-экран не разблокирован.

> § <br> ПРИНЦИПЫ МОДУЛЬНОСТИ

## Роль index.html
`index.html` служит только точкой подключения всех скриптов и стилей. Вся разметка компонентов, шаблоны и логика вынесены в отдельные модули.

## Вынос x-template шаблонов
- Шаблоны компонентов хранятся в `shared/templates/` как отдельные JavaScript файлы (по одному шаблону на файл)
- Формат: каждый шаблон определён как строка в константе `TEMPLATE` и автоматически вставляется в DOM при загрузке файла
- Загрузка: шаблоны загружаются через модульную систему загрузки (`core/module-loader.js`) ДО инициализации Vue.js
- Шаблоны вставляются в DOM как `⟨script type="text/x-template"⟩` элементы автоматически при загрузке каждого файла
- **Преимущество**: работает с `file://` протоколом (не требует fetch/XMLHttpRequest), каждый шаблон документирован отдельно
- **Структура**: `shared/templates/{component-name}-template.js` для переиспользуемых компонентов из `shared/components/`
- **Примечание**: Структура `features/<feature-name>/templates/` зарезервирована на будущее для feature-specific шаблонов

## Модульная система загрузки скриптов
**Статус**: Реализована.

**Реализация:**
- Конфигурационный файл `core/modules-config.js` описывает все модули и их зависимости
- Модули группируются по категориям: `utilities`, `core`, `templates`, `libraries`, `components`, `app`
- Загрузчик модулей `core/module-loader.js` читает конфигурацию и загружает модули в правильном порядке
- Автоматическое разрешение зависимостей через топологическую сортировку (алгоритм Kahn)
- Обнаружение циклических зависимостей
- Поддержка работы с `file://` и `http://` протоколами через асинхронную загрузку `⟨script⟩` тегов
- В `index.html` остаётся только подключение конфигурации и загрузчика модулей

**Структура конфигурации:**
- Каждый модуль описывается объектом с полями: `id`, `src`, `type` (`local` | `external`), `deps` (массив ID зависимостей), `category`
- Зависимости указываются через ID модулей
- Загрузчик автоматически определяет правильный порядок загрузки на основе зависимостей

**Преимущества:**
- Централизованное управление зависимостями
- Автоматическая проверка порядка загрузки
- Легко добавлять/удалять модули
- Поддержка `file://` и `http://` протоколов
- Детальные сообщения об ошибках
- Кэширование загруженных модулей (избежание повторной загрузки)
- Улучшенная обработка ошибок (критичные модули прерывают загрузку, некритичные продолжают)
- Условная загрузка модулей через feature flags (опциональное поле `condition`)

**Дополнительные возможности:**
- Кэширование: модули кэшируются после загрузки, повторная загрузка не выполняется
- Обработка ошибок: критичные модули (app, vue, все шаблоны) при ошибке прерывают загрузку; некритичные модули пропускаются с предупреждением
- Feature flags: каждый модуль может иметь опциональное поле `condition` (функция), которая определяет, нужно ли загружать модуль

## Классификация компонентов и стилей

**Тип 1: Bootstrap Wrappers** (`styles/wrappers/`)
- Vue-обертки над Bootstrap компонентами
- Примеры: `button`, `dropdown`, `dropdown-menu-item`, `button-group`
- Используют только Bootstrap классы, добавляют адаптивность и логику
- Стили: `styles/wrappers/{component-name}.css`
- Компоненты: `shared/components/{component-name}.js`
- Шаблоны: `shared/templates/{component-name}-template.js`

**Тип 2: Layout Components** (`styles/layout/`)
- Компоненты макета приложения
- Примеры: `header`, `footer`
- Могут использовать кастомные стили для позиционирования и оформления
- Стили: `styles/layout/{component-name}.css`
- Компоненты: `app/components/{component-name}.js`
- Шаблоны: `app/templates/{component-name}-template.js`

**Тип 3: Custom Components** (`styles/custom/`)
- Кастомные компоненты, не являющиеся обертками над Bootstrap
- Примеры: ячейка таблицы, заголовок колонки, специфичные виджеты
- Могут использовать кастомные стили и Bootstrap утилиты
- Стили: `styles/custom/{component-name}.css`
- Компоненты: `app/components/{component-name}.js` или `shared/components/{component-name}.js` (в зависимости от переиспользуемости)
- Шаблоны: `app/templates/{component-name}-template.js` или `shared/templates/{component-name}-template.js`

## Группировка компонентов и модулей
- По функциональности (`features/`): **зарезервировано на будущее** — markets, settings, layout (каждая feature будет содержать компоненты, утилиты, шаблоны, стили, конфигурацию)
- По слоям архитектуры: `core/` (базовые утилиты), `domain/` (бизнес-логика), `shared/` (переиспользуемые компоненты), `app/` (корневой компонент)
- По типу файлов: `shared/components/` (переиспользуемые обертки над Bootstrap), `app/components/` (компоненты приложения), `styles/wrappers/` (стили оберток), `styles/layout/` (стили макета), `styles/custom/` (кастомные стили), `core/api/` (API-утилиты), `features/*/components/` (feature-specific компоненты — зарезервировано)
- Разделение shared/app/feature-specific: `shared/` — переиспользуемые обертки над Bootstrap (button, dropdown, dropdown-menu-item, combobox, button-group), утилиты (pluralize, hash-generator, auto-markup). `app/components/` — компоненты приложения (app-header, app-footer). `styles/wrappers/` — стили оберток над Bootstrap. `styles/layout/` — стили компонентов макета. `styles/custom/` — кастомные компоненты. `features/` — зарезервировано на будущее для feature-specific компонентов и утилит.

## Правила размещения файлов
- Шаблоны: `shared/templates/{component-name}-template.js` (переиспользуемые компоненты), `app/templates/{component-name}-template.js` (компоненты приложения) или `features/<feature-name>/templates/{component-name}-template.js` (feature-specific — зарезервировано)
- Компоненты Vue: `shared/components/<component-name>.js` (переиспользуемые обертки над Bootstrap), `app/components/<component-name>.js` (компоненты приложения) или `features/<feature-name>/components/<component-name>.js` (feature-specific — зарезервировано)
- Стили:
  - `styles/wrappers/{component-name}.css` — обертки над Bootstrap компонентами
  - `styles/layout/{component-name}.css` — компоненты макета (header, footer)
  - `styles/custom/{component-name}.css` — кастомные компоненты
  - `features/<feature-name>/styles/<component-name>.css` (feature-specific — зарезервировано)
- Утилиты: `shared/utils/<utility-name>.js` (общие) или `features/<feature-name>/utils/<utility-name>.js` (feature-specific — зарезервировано)
- Конфигурация: `shared/config/<config-name>.js` (общая) или `features/<feature-name>/config/<config-name>.js` (feature-specific — зарезервировано)
- Утилиты API: `core/api/<api-name>.js` (чистые функции, не Vue)
- Математические модели: `mm/<model-name>/utils/`, `mm/<model-name>/core/`, `mm/<model-name>/metrics/`

## Порядок загрузки
1. Bootstrap CSS и внешние стили
2. Локальные стили (порядок важен!):
   - `styles/wrappers/` — обертки над Bootstrap (базовые → составные)
   - `styles/layout/` — компоненты макета (header, footer)
   - `styles/custom/` — кастомные компоненты
3. Font Awesome 6 и Material Symbols
4. Bootstrap JS
5. Модульная система загрузки:
   - `core/modules-config.js` — конфигурация модулей
   - `core/module-loader.js` — загрузчик модулей
   - Автоматическая загрузка всех модулей в правильном порядке:
     - Утилиты (`utilities`): hash-generator, auto-markup, pluralize, class-manager, layout-sync
     - Core модули (`core`): cache, validation, errors, api (market-metrics, perplexity), config (app-config, modals-config), events, state, logging (в порядке зависимостей)
     - Шаблоны (`templates`): button-template, dropdown-menu-item-template, dropdown-template, combobox-template, button-group-template, modal-template, modal-buttons-template, timezone-selector-template, perplexity-settings-template, app-header-template, app-footer-template
     - Библиотеки (`libraries`): vue
     - Компоненты (`components`): dropdown-menu-item, button, dropdown, combobox, button-group, modal, modal-buttons, timezone-selector, app-header, app-footer, modal-example-body, perplexity-settings, timezone-modal-body
     - Приложение (`app`): app-ui-root

**Порядок загрузки модулей определяется автоматически** на основе зависимостей, описанных в `core/modules-config.js`. Загрузчик использует топологическую сортировку для определения правильной последовательности.

**Пример порядка загрузки** (автоматически определяется):
1. Утилиты без зависимостей (hash-generator, pluralize)
2. Core модули без зависимостей (storage-layers, cache-config, validation-schemas, и т.д.)
3. Core модули с зависимостями (cache-manager зависит от storage-layers, cache-config, cache-migrations)
4. Шаблоны (button-template, dropdown-menu-item-template, dropdown-template, combobox-template)
5. Auto-markup (зависит от hash-generator)
6. Layout-sync (зависит от DOM, автоматически инициализируется)
7. Vue.js (зависит от всех шаблонов)
7. Компоненты (зависят от vue и утилит)
8. Приложение (app-ui-root зависит от всех компонентов)

## Принципы именования
- Файлы компонентов: kebab-case (`button.js`, `system-messages.js` и т.д.)
- Файлы шаблонов: kebab-case с суффиксом `-template` (`button-template.html` и т.п.)
- Файлы утилит: kebab-case (`coingecko.js`, `table-sort-mixin.js` и т.д.)
- ID шаблонов в DOM: kebab-case (соответствует имени файла без расширения)
- Файлы документации: префикс `doc-` (`doc-architect.md` и т.п.)
- Файлы тематических логов: префикс `log-` (файлы в папке `docs/logs/`)

## Работа без сборки
Проект должен работать на GitHub Pages (HTTPS) и локально через `file://` протокол без использования bundler'ов. Ограничения: нет ES6 модулей (import/export), использование глобальных переменных через `window.*`, динамическая загрузка через `fetch()` и создание `<script>` тегов, относительные пути к файлам.

> § <br> ПРИНЦИПЫ КЭШИРОВАНИЯ

## Архитектура кэширования
Единая система кэширования через `core/cache/cache-manager.js` обеспечивает абстракцию над хранилищами (localStorage, IndexedDB), версионирование данных, автоматические миграции и стратегии кэширования. Все компоненты работают с кэшем через единый интерфейс, что позволяет менять реализацию без изменения кода компонентов.

## Слои хранения
- **Hot (localStorage)**: небольшие данные (< 5MB), частый доступ — настройки, избранное, UI-состояние, иконки монет
- **Warm (IndexedDB)**: средний объём (5–50MB), частый доступ — список монет, метрики рынка, кэш API-ответов
- **Cold (IndexedDB)**: большие объёмы (50MB+), редкий доступ — временные ряды, история портфелей, стратегии, корреляции

## Стратегии кэширования
- **cache-first**: иконки, список монет — всегда из кэша, обновление в фоне
- **network-first**: метрики рынка, цены — сначала сеть, fallback на кэш
- **stale-while-revalidate**: временные ряды, история — показываем кэш, обновляем в фоне
- **cache-only**: портфели пользователя, стратегии, настройки Perplexity (API ключ, модель), таймзона, язык перевода — только локальные данные, без TTL

## TTL в cache-config.js

Все значения TTL (Time To Live) централизованы в `core/cache/cache-config.js`. Компоненты используют `cacheConfig.getTTL(key)` вместо хардкода значений.

**TTL для различных типов данных:**
- `icons-cache`: 1 час
- `coins-list`: 1 день
- `market-metrics`: 1 час
- `api-cache`: 5 минут
- `time-series`: 1 час
- `history`: 1 день
- `crypto-news-cache-max-age`: 24 часа — максимальный возраст кэша новостей криптовалют
- `market-update-fallback`: 3 часа — fallback при ошибке расчета времени обновления метрик
- `market-update-delay-max`: 24 часа — максимальная задержка обновления метрик

**Пример использования:**
```javascript
// Вместо хардкода:
const maxAge = 24 * 60 * 60 * 1000; // ❌

// Используем конфигурацию:
const maxAge = window.cacheConfig.getTTL('crypto-news-cache-max-age'); // ✅
```

## Кэширование новостей Perplexity
Новости криптовалют, получаемые через Perplexity AI, не кэшируются для обеспечения актуальности. В кэше хранится только индекс текущей новости (0-4) и timestamp последнего запроса. При каждом клике на новость загружается свежая новость с переводом на выбранный язык. Это обеспечивает актуальность данных и экономит место в кэше, так как новости быстро устаревают.

Максимальный возраст кэша состояния новостей (24 часа) определяется через `cacheConfig.getTTL('crypto-news-cache-max-age')` вместо хардкода.

## Версионирование данных (миграции схем)
Каждая запись в кэше содержит версию схемы данных. При изменении структуры данных (например, `archivedCoins` из массива строк в объекты) автоматически запускаются миграции из `core/cache/cache-migrations.js`. Это обеспечивает совместимость при обновлении приложения и предотвращает потерю данных пользователей.

## Версионирование приложения (инвалидация кэша)
Версия приложения из `app-config.js` (CONFIG.version) используется для генерации детерминированного хэша. Этот хэш применяется как:
- **CSS-класс на body**: `app-version-{hash}` для версионной стилизации и отладки
- **Префикс ключей кэша**: `v:{hash}:{key}` для автоматической инвалидации при смене версии
- **Автоматическая очистка**: при инициализации удаляются ключи с префиксом старых версий

Версионируются только ключи, зависящие от структуры данных приложения (`icons-cache`, `coins-list`, `api-cache`, `market-metrics`, `crypto-news-state`). Пользовательские данные (`settings`, `portfolios`, `strategies`) не версионируются и сохраняются между обновлениями. Критерии применения версионирования описаны в разделе "Версионирование приложения".

## Индексация и производительность
IndexedDB использует индексы для быстрого поиска: временные ряды индексируются по `coinId` и `timestamp`, портфели — по `userId` и `createdAt`, стратегии — по `type` и `isActive`. Индексы определяются в `core/cache/cache-indexes.js` при инициализации хранилища.

## Очистка и квоты
Автоматическая очистка старых данных по политикам из `core/cache/cache-cleanup.js`: временные ряды старше 90 дней сжимаются (1 точка в час), история портфелей старше 1 года архивируется. При достижении квот хранилища запускается приоритетная очистка (сначала cold, затем warm, hot очищается только при критическом переполнении).

> § <br> КРИТИЧЕСКИ ВАЖНЫЕ СТРУКТУРЫ

## Валидация и схемы данных
Схемы валидации в `core/validation/schemas.js` определяют структуру и типы данных для API-ответов (CoinGecko, метрики рынка), временных рядов, портфелей и стратегий. Валидация выполняется через `core/validation/validator.js` перед использованием данных в расчётах. Нормализация данных в `core/validation/normalizer.js` приводит данные к единому формату независимо от источника. Это предотвращает ошибки в математических моделях из-за некорректных данных.

## Обработка ошибок
Единая система обработки ошибок в `core/errors/error-handler.js` классифицирует ошибки (API, валидация, вычисления, сеть), логирует их через `core/logging/logger.js`, показывает пользовательские сообщения и выполняет автоматические повторные попытки с fallback-стратегиями. Классы ошибок в `core/errors/error-types.js` определяют типы ошибок и их обработку. Это обеспечивает предсказуемое поведение при ошибках и упрощает отладку.

## Rate limiting и адаптивные таймауты
Централизованное управление запросами к API через `core/api/rate-limiter.js`: адаптивные таймауты (увеличение при 429 ошибках, уменьшение при успешных запросах), очередь запросов с приоритизацией, обработка rate limiting для всех внешних API. Базовые параметры и стратегии определяются в `core/config/api-config.js`. Это предотвращает блокировку API при массовых операциях и обеспечивает стабильную работу.

## Система состояний загрузки
Единый подход к состояниям загрузки через `core/state/loading-state.js`: управление состояниями (loading, error, success), индикаторы прогресса, обработка множественных загрузок, отмена запросов. Компоненты используют `window.loadingState` для синхронизации состояний. Это предотвращает конфликты состояний и обеспечивает единообразный UX.

## Событийная система
Глобальная шина событий в `core/events/event-bus.js` обеспечивает коммуникацию между компонентами без жёстких зависимостей. События: `data-updated`, `portfolio-changed`, `error-occurred`, `cache-invalidated`. Компоненты подписываются через `window.eventBus.on()` и эмитят через `window.eventBus.emit()`. Это позволяет компонентам синхронизироваться при изменении данных без дублирования логики.

## Валидация математических вычислений
Проверка корректности расчётов через `core/validation/math-validation.js`: проверка диапазонов значений (веса портфеля: сумма = 1, корреляции: -1 до 1), валидация метрик (не NaN, не Infinity), проверка временных рядов (монотонность времени, отсутствие пропусков). Это предотвращает ошибки в финансовых расчётах и обеспечивает корректность результатов.

## Конфигурация приложения
Централизованная конфигурация в `core/config/app-config.js`: API endpoints, лимиты и таймауты, настройки по умолчанию, версия приложения, feature flags. Конфигурация загружается при инициализации и доступна через `window.appConfig`. Это упрощает изменение настроек и тестирование различных конфигураций.

## Логирование
Структурированное логирование через `core/logging/logger.js` с уровнями (debug, info, warn, error) и контекстом (компонент, действие). Логи форматируются единообразно и могут быть отправлены на сервер для мониторинга (если понадобится). Это упрощает отладку финансовых расчётов и поиск проблем в production.

## Система управления кнопками модального окна
Единая система управления кнопками в header и footer модального окна через `provide/inject` в `shared/components/modal.js`. Компоненты внутри `body` модального окна регистрируют кнопки через `modalApi.registerButton()`, указывая места отображения (header, footer или оба). Одна кнопка регистрируется один раз с единым состоянием (disabled, visible, onClick), но может отображаться в нескольких местах одновременно. Состояние кнопки реактивно обновляется во всех местах через `modalApi.updateButton()`. Компонент `shared/components/modal-buttons.js` рендерит кнопки в указанном месте на основе единого реестра. Это устраняет дублирование функциональности кнопок и обеспечивает единообразие управления состоянием модального окна. Подробности в `docs/doc-comp-principles.md` (раздел "Система управления кнопками модального окна").

> § <br> БИБЛИОТЕКИ И ЗАВИСИМОСТИ

## Приоритет библиотек
Перед написанием кастомного модуля **обязательно** проверь наличие подходящих Vue-библиотек с расширяемым API. Приоритет библиотекам, которые имеют плагины, composables, возможность кастомизации. Кастомные модули создаются только если библиотека не существует, слишком тяжёлая или требуется специфичная бизнес-логика. Подробности в `docs/doc-lib-vue.md`.

## Схема хранения библиотек
Библиотеки хранятся в отдельном репозитории `https://github.com/aoponomarev/libs` и раздаются через GitHub Pages CDN по адресу `https://aoponomarev.github.io/libs/`. Структура: `lib-name/version/file.js`. Это обеспечивает контроль версий, единый репозиторий для всех проектов и простоту обновления библиотек.

## Механизм загрузки
Загрузка библиотек через `core/lib-loader.js` с автоматическим fallback: 1) GitHub Pages CDN (`https://aoponomarev.github.io/libs/`) — основной источник, 2) внешние CDN (jsdelivr, cdnjs) — fallback при недоступности, 3) локальное хранение (`./libs/`) — для критичных библиотек. Это обеспечивает надёжность загрузки даже при недоступности отдельных источников.

