# Принципы работы с компонентами

> Оглавление `docs/doc-comp-principles.md`
- § *Приоритет библиотек* — использование готовых библиотек перед кастомными компонентами.
- § *Использование Bootstrap* — нативные компоненты Bootstrap вместо кастомных обёрток.
- § *Запрет кастомных стилей* — использование только Bootstrap классов и утилит.
- § *Адаптивность компонентов* — управление видимостью элементов через CSS классы.
- § *Единый источник правды* — устранение дублирования разметки и данных через переиспользуемые компоненты.
- § *Система управления кнопками модального окна* — единая система управления кнопками в header и footer модального окна.

> § <br> ПРИОРИТЕТ БИБЛИОТЕК

Перед созданием кастомного компонента **обязательно** проверь наличие подходящих Vue-библиотек с расширяемым API. Приоритет библиотекам, которые имеют плагины, composables, возможность кастомизации. Кастомные компоненты создаются только если библиотека не существует, слишком тяжёлая или требуется специфичная бизнес-логика. Подробности в `docs/doc-lib-vue.md`.

> § <br> ИСПОЛЬЗОВАНИЕ BOOTSTRAP

## Базовый принцип

Нативные компоненты Bootstrap 5 (dropdown, modal, tooltip, popover и т.п.) используются напрямую через классы и JavaScript API без создания кастомных Vue-обёрток. Bootstrap предоставляет полный функционал: клавиатурную навигацию, позиционирование через Popper.js, управление через JavaScript API, поддержку тем.

## Когда создавать Vue-обёртки

Кастомные Vue-компоненты-обёртки над Bootstrap создаются **только** если требуется дополнительная функциональность, которой нет в нативном Bootstrap:
- Поиск по элементам (например, в dropdown)
- Прокрутка для длинных списков
- Кастомная логика фильтрации/сортировки
- Динамическая загрузка элементов

**Важно:** Кастомные компоненты создаются только для элементов внутри нативных Bootstrap-компонентов (например, пункты меню внутри `dropdown-menu`). Контейнеры Bootstrap (`<div class="dropdown">`, `<div class="modal">` и т.п.) остаются под управлением Bootstrap без Vue-обёрток, **кроме случаев**, когда требуется расширенная функциональность.

## Стратегия максимальной совместимости с Bootstrap (обязательное требование)

При создании Vue-обёрток над Bootstrap-компонентами **обязательно** соблюдать следующие принципы:

1. **Инициализация через Bootstrap JavaScript API:**
   - Использовать `new bootstrap.Dropdown()`, `new bootstrap.Modal()` и т.п.
   - Сохранять ссылку на экземпляр Bootstrap в `data()` или `ref`
   - Инициализировать в `mounted()` через `$nextTick()`

2. **Подписка на события Bootstrap:**
   - Подписываться на события Bootstrap (`show.bs.dropdown`, `hide.bs.dropdown`, `shown.bs.modal` и т.п.)
   - Синхронизировать состояние Vue с состоянием Bootstrap
   - Эмитить события Vue на основе событий Bootstrap

3. **Программный доступ к Bootstrap API:**
   - Предоставлять методы для программного управления (`show()`, `hide()`, `toggle()`)
   - Предоставлять метод `getBootstrapInstance()` для прямого доступа к экземпляру Bootstrap
   - Не блокировать стандартные способы управления Bootstrap

4. **Уничтожение экземпляров:**
   - Вызывать `instance.dispose()` в `beforeUnmount()` для предотвращения утечек памяти
   - Очищать подписки на события

5. **Использование нативных атрибутов Bootstrap:**
   - Сохранять `data-bs-toggle`, `data-bs-target` и другие data-атрибуты
   - Не переопределять стандартное поведение Bootstrap без необходимости

6. **Совместимость с темами:**
   - Использовать только Bootstrap классы и CSS-переменные
   - Не добавлять кастомные стили, которые могут конфликтовать с темами

**Пример правильной реализации:**
```javascript
mounted() {
    this.$nextTick(() => {
        if (window.bootstrap && window.bootstrap.Dropdown) {
            this.dropdownInstance = new window.bootstrap.Dropdown(toggleElement);

            // Подписка на события Bootstrap
            container.addEventListener('show.bs.dropdown', () => {
                this.isOpen = true;
                this.$emit('show');
            });
        }
    });
},

beforeUnmount() {
    if (this.dropdownInstance) {
        this.dropdownInstance.dispose();
    }
},

methods: {
    show() {
        if (this.dropdownInstance) {
            this.dropdownInstance.show();
        }
    },

    getBootstrapInstance() {
        return this.dropdownInstance;
    }
}
```

> § <br> ЗАПРЕТ КАСТОМНЫХ СТИЛЕЙ

Все компоненты используют только Bootstrap классы и утилиты. Кастомный CSS, inline-стили и `<style>`-блоки запрещены, кроме минимальных исключений (например, inline `transition` для анимации chevron в `dropdown-menu-item`). Подробности в `docs/doc-architect.md` (раздел "Фреймворки и UI").

> § <br> ЕДИНЫЙ ИСТОЧНИК ПРАВДЫ (SINGLE SOURCE OF TRUTH)

## Базовый принцип

При наличии дублирующейся разметки, данных или логики в нескольких местах (например, в статических примерах и реальных компонентах, в разных инстансах одного компонента) необходимо выносить общую часть в отдельный переиспользуемый компонент. Это гарантирует единообразие, упрощает поддержку и устраняет риск рассинхронизации.

## Когда выносить в компонент

Выносить в отдельный компонент следует, если:
- Одна и та же разметка повторяется в двух и более местах
- Список опций, конфигурация или данные дублируются
- Логика обработки данных повторяется
- Изменения должны синхронизироваться между всеми инстансами

**Примеры:**
- Список таймзон в нескольких модальных окнах → компонент `timezone-selector`
- Форма ввода с одинаковыми полями в разных местах → компонент формы
- Список опций в нескольких dropdown → компонент списка опций

## Как выносить

1. **Создать компонент:**
   - Компонент: `shared/components/<component-name>.js`
   - Шаблон: `shared/templates/<component-name>-template.js`
   - Регистрация в `core/modules-config.js`

2. **Определить API компонента:**
   - Props для входных данных
   - Emits для выходных событий
   - Поддержка `v-model` если требуется двусторонняя привязка

3. **Заменить дублирующуюся разметку:**
   - Использовать компонент во всех местах, где была дублирующаяся разметка
   - Передавать данные через props
   - Обрабатывать события через emits

## Пример реализации

**Проблема:** Разметка выбора таймзоны дублировалась в статическом примере и реальном модальном окне.

**Решение:**
```javascript
// shared/components/timezone-selector.js
window.cmpTimezoneSelector = {
    template: '#timezone-selector-template',
    props: { modelValue: String },
    emits: ['update:modelValue']
};
```

**Использование:**
```html
<!-- Вместо дублирующегося <select> с опциями -->
<cmp-timezone-selector v-model="selectedTimezone"></cmp-timezone-selector>
```

## Преимущества

- **Единообразие:** Все инстансы используют один и тот же компонент
- **Упрощение поддержки:** Изменения вносятся в одном месте
- **Синхронизация:** Данные автоматически синхронизируются через Vue
- **Переиспользование:** Компонент можно использовать в любом месте приложения

> § <br> АДАПТИВНОСТЬ КОМПОНЕНТОВ

Адаптивность компонентов (видимость иконок, текста, коротких текстов) управляется через CSS классы компонентов с вложенными селекторами. Подробности в `docs/doc-guide-ii.md` (раздел "Компоненты" → "Адаптивность компонентов").

> § <br> СИСТЕМА УПРАВЛЕНИЯ КНОПКАМИ МОДАЛЬНОГО ОКНА

## Базовый принцип

Модальное окно (`cmp-modal`) предоставляет единую систему управления кнопками через `provide/inject`. Компоненты внутри `body` модального окна могут регистрировать кнопки для отображения в `header` и/или `footer` без дублирования функциональности. Одна кнопка регистрируется один раз, но может отображаться в нескольких местах одновременно.

## Ключевые особенности

1. **Единый источник правды:** Кнопка регистрируется один раз с единым состоянием (disabled, visible, onClick)
2. **Гибкость размещения:** Одна кнопка может отображаться в header, footer или в обоих местах одновременно
3. **Реактивность:** Обновление состояния кнопки автоматически отражается во всех местах отображения
4. **Без дублирования:** Один обработчик `onClick`, одно состояние `disabled`, одна логика для всех мест

## API системы управления кнопками

Компонент `cmp-modal` предоставляет через `provide` объект `modalApi` со следующими методами:

- `registerButton(buttonId, config)` — регистрация кнопки
  - `buttonId` (String) — уникальный ID кнопки
  - `config.locations` (String|Array) — где отображать: 'header', 'footer', или ['header', 'footer']
  - `config.label` (String) — текст кнопки
  - `config.variant` (String) — вариант Bootstrap (primary, secondary, и т.д.)
  - `config.onClick` (Function) — обработчик клика
  - `config.disabled` (Boolean) — состояние disabled
  - `config.visible` (Boolean) — видимость кнопки
  - `config.classesAdd` (Object) — дополнительные классы для cmp-button
  - `config.buttonAttributes` (Object) — атрибуты для передачи на корневой элемент button
  - `config.icon` (String) — CSS класс иконки

- `updateButton(buttonId, updates)` — обновление состояния кнопки (реактивно обновляется во всех местах)
- `removeButton(buttonId)` — удаление кнопки
- `getButton(buttonId)` — получение конфигурации кнопки
- `getButtonsForLocation(location)` — получение кнопок для конкретного места (header/footer)

## Использование

### Регистрация кнопок из компонента body

```javascript
// В компоненте внутри body модального окна
export default {
    inject: ['modalApi'],

    mounted() {
        // Кнопка "Сохранить" в header и footer одновременно
        this.modalApi.registerButton('save', {
            locations: ['header', 'footer'],
            label: 'Сохранить',
            variant: 'primary',
            disabled: false,
            onClick: () => this.handleSave()
        });

        // Кнопка "Отмена" только в footer
        this.modalApi.registerButton('cancel', {
            locations: ['footer'],
            label: 'Отмена',
            variant: 'secondary',
            classesAdd: { root: 'me-auto' },
            onClick: () => this.handleCancel()
        });
    },

    watch: {
        formData: {
            deep: true,
            handler() {
                // Реактивно обновляем состояние кнопки
                // Обновится ВО ВСЕХ местах автоматически
                this.modalApi.updateButton('save', {
                    disabled: !this.hasChanges || !this.isValid
                });
            }
        }
    },

    beforeUnmount() {
        // Удаляем кнопки при размонтировании
        this.modalApi.removeButton('save');
        this.modalApi.removeButton('cancel');
    }
}
```

### Совместимость со слотами

Система управления кнопками работает параллельно со слотами. Можно использовать:
- Только слоты (традиционный подход)
- Только динамические кнопки (через modalApi)
- Комбинацию слотов и динамических кнопок

## Преимущества

- **Единообразие:** Одна кнопка — один источник правды
- **Реактивность:** Состояние кнопки синхронизируется автоматически
- **Гибкость:** Кнопка может быть в header, footer или в обоих местах
- **Расширяемость:** Легко добавлять новые кнопки в любое место
- **Упрощение:** Не нужно дублировать кнопки для разных мест

## ССЫЛКИ

- Компонент модального окна: `shared/components/modal.js`
- Компонент рендеринга кнопок: `shared/components/modal-buttons.js`
- Пример использования: `app/components/modal-example-body.js`

