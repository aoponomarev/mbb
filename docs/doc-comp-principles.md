# Принципы работы с компонентами

> Оглавление `docs/doc-comp-principles.md`
- § *Приоритет библиотек* — использование готовых библиотек перед кастомными компонентами.
- § *Использование Bootstrap* — нативные компоненты Bootstrap вместо кастомных обёрток.
- § *Запрет кастомных стилей* — использование только Bootstrap классов и утилит.
- § *Адаптивность компонентов* — управление видимостью элементов через CSS классы.
- § *Единый источник правды* — устранение дублирования разметки и данных через переиспользуемые компоненты.
- § *Система управления кнопками модального окна* — единая система управления кнопками в header и footer модального окна.

> § <br> ПРИОРИТЕТ БИБЛИОТЕК

Перед созданием кастомного компонента **обязательно** проверь наличие подходящих Vue-библиотек с расширяемым API. Приоритет библиотекам, которые имеют плагины, composables, возможность кастомизации. Кастомные компоненты создаются только если библиотека не существует, слишком тяжёлая или требуется специфичная бизнес-логика. Подробности в `docs/doc-lib-vue.md`.

> § <br> ИСПОЛЬЗОВАНИЕ BOOTSTRAP

## Базовый принцип

Нативные компоненты Bootstrap 5 (dropdown, modal, tooltip, popover и т.п.) используются напрямую через классы и JavaScript API без создания кастомных Vue-обёрток. Bootstrap предоставляет полный функционал: клавиатурную навигацию, позиционирование через Popper.js, управление через JavaScript API, поддержку тем.

## Когда создавать Vue-обёртки

Кастомные Vue-компоненты-обёртки над Bootstrap создаются **только** если требуется дополнительная функциональность, которой нет в нативном Bootstrap:
- Поиск по элементам (например, в dropdown)
- Прокрутка для длинных списков
- Кастомная логика фильтрации/сортировки
- Динамическая загрузка элементов

**Важно:** Кастомные компоненты создаются только для элементов внутри нативных Bootstrap-компонентов (например, пункты меню внутри `dropdown-menu`). Контейнеры Bootstrap (`<div class="dropdown">`, `<div class="modal">` и т.п.) остаются под управлением Bootstrap без Vue-обёрток, **кроме случаев**, когда требуется расширенная функциональность.

## Стратегия максимальной совместимости с Bootstrap (обязательное требование)

При создании Vue-обёрток над Bootstrap-компонентами **обязательно** соблюдать следующие принципы:

1. **Инициализация через Bootstrap JavaScript API:**
   - Использовать `new bootstrap.Dropdown()`, `new bootstrap.Modal()` и т.п.
   - Сохранять ссылку на экземпляр Bootstrap в `data()` или `ref`
   - Инициализировать в `mounted()` через `$nextTick()`

2. **Подписка на события Bootstrap:**
   - Подписываться на события Bootstrap (`show.bs.dropdown`, `hide.bs.dropdown`, `shown.bs.modal` и т.п.)
   - Синхронизировать состояние Vue с состоянием Bootstrap
   - Эмитить события Vue на основе событий Bootstrap

3. **Программный доступ к Bootstrap API:**
   - Предоставлять методы для программного управления (`show()`, `hide()`, `toggle()`)
   - Предоставлять метод `getBootstrapInstance()` для прямого доступа к экземпляру Bootstrap
   - Не блокировать стандартные способы управления Bootstrap

4. **Уничтожение экземпляров:**
   - Вызывать `instance.dispose()` в `beforeUnmount()` для предотвращения утечек памяти
   - Очищать подписки на события

5. **Использование нативных атрибутов Bootstrap:**
   - Сохранять `data-bs-toggle`, `data-bs-target` и другие data-атрибуты
   - Не переопределять стандартное поведение Bootstrap без необходимости

6. **Совместимость с темами:**
   - Использовать только Bootstrap классы и CSS-переменные
   - Не добавлять кастомные стили, которые могут конфликтовать с темами

**Пример правильной реализации:**
```javascript
mounted() {
    this.$nextTick(() => {
        if (window.bootstrap && window.bootstrap.Dropdown) {
            this.dropdownInstance = new window.bootstrap.Dropdown(toggleElement);

            // Подписка на события Bootstrap
            container.addEventListener('show.bs.dropdown', () => {
                this.isOpen = true;
                this.$emit('show');
            });
        }
    });
},

beforeUnmount() {
    if (this.dropdownInstance) {
        this.dropdownInstance.dispose();
    }
},

methods: {
    show() {
        if (this.dropdownInstance) {
            this.dropdownInstance.show();
        }
    },

    getBootstrapInstance() {
        return this.dropdownInstance;
    }
}
```

> § <br> ЗАПРЕТ КАСТОМНЫХ СТИЛЕЙ

Все компоненты используют только Bootstrap классы и утилиты. Кастомный CSS, inline-стили и `<style>`-блоки запрещены, кроме минимальных исключений (например, inline `transition` для анимации chevron в `dropdown-menu-item`). Подробности в `docs/doc-architect.md` (раздел "Фреймворки и UI").

> § <br> ЕДИНЫЙ ИСТОЧНИК ПРАВДЫ (SINGLE SOURCE OF TRUTH)

**КРИТИЧЕСКИ ВАЖНО:** Принцип единого источника правды является обязательным требованием для всех изменений в проекте. Нарушение этого принципа недопустимо.

## Базовый принцип

При наличии дублирующейся разметки, данных или логики в нескольких местах (например, в статических примерах и реальных компонентах, в разных инстансах одного компонента) необходимо выносить общую часть в отдельный переиспользуемый компонент или конфигурационный файл. Это гарантирует единообразие, упрощает поддержку и устраняет риск рассинхронизации.

## Области применения

Принцип единого источника правды применяется к:
- **Конфигурационным данным:** заголовки модальных окон, тексты пунктов меню, иконки, метаданные (`core/config/modals-config.js`)
- **Настройкам кэширования:** TTL, версии схем, стратегии кэширования (`core/cache/cache-config.js`)
- **Настройкам приложения:** API endpoints, лимиты, таймауты, feature flags (`core/config/app-config.js`)
- **Конфигурации прокси:** URL прокси-сервисов для AI провайдеров (YandexGPT, GigaChat) хранятся централизованно в `core/config/app-config.js`. Все прокси-сервисы (Cloudflare Workers, Yandex Cloud Functions и т.д.) определены в одном месте для каждого AI провайдера. Пользователь выбирает тип прокси, а URL получается из конфигурации через `appConfig.getProxyUrl()`. Подробности в `docs/archive/gigachat/giga-proxy-architecture.md`
- **Конфигурации модулей:** порядок загрузки, зависимости (`core/modules-config.js`)
- **Разметке и компонентам:** дублирующаяся разметка выносится в переиспользуемые компоненты
- **Данным и логике:** повторяющаяся логика выносится в утилиты или компоненты

## Когда выносить в компонент или конфигурацию

Выносить в отдельный компонент или конфигурационный файл следует, если:
- Одна и та же разметка повторяется в двух и более местах → компонент
- Список опций, конфигурация или данные дублируются → конфигурационный файл (`core/config/`)
- Логика обработки данных повторяется → компонент или утилита
- Изменения должны синхронизироваться между всеми инстансами → компонент или конфигурация
- Значения используются в нескольких местах (заголовки, тексты, настройки) → конфигурационный файл

**Примеры:**
- Список таймзон в нескольких модальных окнах → компонент `timezone-selector`
- Заголовки модальных окон в меню и в модальных окнах → `core/config/modals-config.js`
- TTL и стратегии кэширования → `core/cache/cache-config.js`
- URL прокси для AI провайдеров → `core/config/app-config.js` (структура `defaults.{provider}.proxies`)
- Форма ввода с одинаковыми полями в разных местах → компонент формы
- Список опций в нескольких dropdown → компонент списка опций

## Как выносить

### Для компонентов:

1. **Создать компонент:**
   - Компонент: `shared/components/<component-name>.js`
   - Шаблон: `shared/templates/<component-name>-template.js`
   - Регистрация в `core/modules-config.js`

2. **Определить API компонента:**
   - Props для входных данных
   - Emits для выходных событий
   - Поддержка `v-model` если требуется двусторонняя привязка

3. **Заменить дублирующуюся разметку:**
   - Использовать компонент во всех местах, где была дублирующаяся разметка
   - Передавать данные через props
   - Обрабатывать события через emits

### Для конфигурационных данных:

1. **Создать или использовать конфигурационный файл:**
   - Конфигурация модальных окон: `core/config/modals-config.js`
   - Конфигурация кэширования: `core/cache/cache-config.js`
   - Конфигурация приложения: `core/config/app-config.js`

2. **Определить структуру данных:**
   - Объект с конфигурацией
   - Функции-геттеры для получения значений

3. **Использовать функции-геттеры:**
   - Вместо хардкода использовать `modalsConfig.getModalTitle()`, `cacheConfig.getTTL()` и т.п.
   - Зарегистрировать модуль в `core/modules-config.js` если создан новый файл

## Пример реализации

**Проблема:** Разметка выбора таймзоны дублировалась в статическом примере и реальном модальном окне.

**Решение:**
```javascript
// shared/components/timezone-selector.js
window.cmpTimezoneSelector = {
    template: '#timezone-selector-template',
    props: { modelValue: String },
    emits: ['update:modelValue']
};
```

**Использование:**
```html
<!-- Вместо дублирующегося <select> с опциями -->
<cmp-timezone-selector v-model="selectedTimezone"></cmp-timezone-selector>
```

## Преимущества

- **Единообразие:** Все инстансы используют один и тот же компонент
- **Упрощение поддержки:** Изменения вносятся в одном месте
- **Синхронизация:** Данные автоматически синхронизируются через Vue
- **Переиспользование:** Компонент можно использовать в любом месте приложения

> § <br> АДАПТИВНОСТЬ КОМПОНЕНТОВ

Адаптивность компонентов (видимость иконок, текста, коротких текстов) управляется через CSS классы компонентов с вложенными селекторами. Подробности в `docs/doc-guide-ii.md` (раздел "Компоненты" → "Адаптивность компонентов").

> § <br> СИСТЕМА УПРАВЛЕНИЯ КНОПКАМИ МОДАЛЬНОГО ОКНА

## Базовый принцип

Модальное окно (`cmp-modal`) предоставляет единую систему управления кнопками через `provide/inject`. Компоненты внутри `body` модального окна могут регистрировать кнопки для отображения в `header` и/или `footer` без дублирования функциональности. Одна кнопка регистрируется один раз, но может отображаться в нескольких местах одновременно.

## Ключевые особенности

1. **Единый источник правды:** Кнопка регистрируется один раз с единым состоянием (disabled, visible, onClick)
2. **Гибкость размещения:** Одна кнопка может отображаться в header, footer или в обоих местах одновременно
3. **Реактивность:** Обновление состояния кнопки автоматически отражается во всех местах отображения
4. **Без дублирования:** Один обработчик `onClick`, одно состояние `disabled`, одна логика для всех мест

## API системы управления кнопками

Компонент `cmp-modal` предоставляет через `provide` объект `modalApi` со следующими методами:

- `registerButton(buttonId, config)` — регистрация кнопки
  - `buttonId` (String) — уникальный ID кнопки
  - `config.locations` (String|Array) — где отображать: 'header', 'footer', или ['header', 'footer']
  - `config.label` (String) — текст кнопки
  - `config.variant` (String) — вариант Bootstrap (primary, secondary, и т.д.)
  - `config.onClick` (Function) — обработчик клика
  - `config.disabled` (Boolean) — состояние disabled
  - `config.visible` (Boolean) — видимость кнопки
  - `config.classesAdd` (Object) — дополнительные классы для cmp-button
  - `config.buttonAttributes` (Object) — атрибуты для передачи на корневой элемент button
  - `config.icon` (String) — CSS класс иконки

- `updateButton(buttonId, updates)` — обновление состояния кнопки (реактивно обновляется во всех местах)
- `removeButton(buttonId)` — удаление кнопки
- `getButton(buttonId)` — получение конфигурации кнопки
- `getButtonsForLocation(location)` — получение кнопок для конкретного места (header/footer)

## Использование

### Регистрация кнопок из компонента body

```javascript
// В компоненте внутри body модального окна
export default {
    inject: ['modalApi'],

    mounted() {
        // Кнопка "Сохранить" в header и footer одновременно
        this.modalApi.registerButton('save', {
            locations: ['header', 'footer'],
            label: 'Сохранить',
            variant: 'primary',
            disabled: false,
            onClick: () => this.handleSave()
        });

        // Кнопка "Отмена" только в footer
        this.modalApi.registerButton('cancel', {
            locations: ['footer'],
            label: 'Отмена',
            variant: 'secondary',
            classesAdd: { root: 'me-auto' },
            onClick: () => this.handleCancel()
        });
    },

    watch: {
        formData: {
            deep: true,
            handler() {
                // Реактивно обновляем состояние кнопки
                // Обновится ВО ВСЕХ местах автоматически
                this.modalApi.updateButton('save', {
                    disabled: !this.hasChanges || !this.isValid
                });
            }
        }
    },

    beforeUnmount() {
        // Удаляем кнопки при размонтировании
        this.modalApi.removeButton('save');
        this.modalApi.removeButton('cancel');
    }
}
```

### Совместимость со слотами

Система управления кнопками работает параллельно со слотами. Можно использовать:
- Только слоты (традиционный подход)
- Только динамические кнопки (через modalApi)
- Комбинацию слотов и динамических кнопок

## Правила использования кнопок в модальных окнах

### Кнопка "Закрыть"
- **Не используется:** Закрытие модального окна выполняется только через крестик в header (btn-close) или клик вне модального окна (backdrop)

### Кнопка "Отмена"
- **Обязательна в footer** для форм с изменяемыми полями
- **Поведение:**
  - На форме с измененными данными: первый клик восстанавливает исходные значения полей, второй клик закрывает окно
  - На форме без изменений: клик сразу закрывает окно

### Кнопка "Сохранить"
- **Обязательна в footer**, если есть изменяемые поля
- **Два состояния:**
  1. **Обычное состояние:** "Сохранить" (variant: 'primary')
     - `disabled: true` если нет изменений или форма невалидна
     - При клике: сохраняет данные, переходит в состояние "Сохранено, закрыть?"
  2. **Состояние успеха:** "Сохранено, закрыть?" (variant: 'success')
     - `disabled: false` (всегда enabled)
     - При клике: закрывает модальное окно
     - Автоматически сбрасывается в обычное состояние при изменении любых полей формы
- **Важно:** Кнопка "Сохранить" НЕ закрывает модальное окно напрямую при первом клике. Закрытие происходит только через:
  - Крестик в header
  - Клик вне модального окна (backdrop)
  - Второй клик в состоянии "Сохранено, закрыть?"

### Пример реализации состояния "Сохранено, закрыть?"

```javascript
data() {
    return {
        isSaved: false // Состояние успешного сохранения
    };
},

methods: {
    async saveSettings() {
        // Если уже сохранено - закрываем модальное окно
        if (this.isSaved) {
            this.closeModal();
            return;
        }

        // Сохраняем данные
        await this.saveData();

        // Переводим кнопку в состояние "Сохранено, закрыть?"
        this.isSaved = true;
        this.updateSaveButton();
    },

    updateSaveButton() {
        if (this.isSaved) {
            this.modalApi.updateButton('save', {
                label: 'Сохранено, закрыть?',
                variant: 'success',
                disabled: false
            });
        } else {
            this.modalApi.updateButton('save', {
                label: 'Сохранить',
                variant: 'primary',
                disabled: !this.hasChanges || !this.isValid
            });
        }
    }
},

watch: {
    formField() {
        // Сбрасываем состояние сохранения при изменении полей
        if (this.isSaved) {
            this.isSaved = false;
            this.updateSaveButton();
        }
    }
}
```

## Преимущества

- **Единообразие:** Одна кнопка — один источник правды
- **Реактивность:** Состояние кнопки синхронизируется автоматически
- **Гибкость:** Кнопка может быть в header, footer или в обоих местах
- **Расширяемость:** Легко добавлять новые кнопки в любое место
- **Упрощение:** Не нужно дублировать кнопки для разных мест

## ССЫЛКИ

- Компонент модального окна: `shared/components/modal.js`
- Компонент рендеринга кнопок: `shared/components/modal-buttons.js`
- Пример использования: `app/components/modal-example-body.js`

> § <br> ЕДИНЫЙ ИСТОЧНИК ПРАВДЫ ДЛЯ ЗАГОЛОВКОВ МОДАЛЬНЫХ ОКОН

## Обязательное требование

**Заголовок модального окна должен быть идентичен тексту пункта меню/кнопки/ссылки, которая его открывает.**

Это обеспечивает консистентность UX и предотвращает путаницу пользователя.

## Реализация через modals-config.js

Конфигурация всех модальных окон централизована в `core/config/modals-config.js`. Это единый источник правды для:
- Заголовков модальных окон
- Иконок для пунктов меню
- Описаний (опционально)

### Использование

```javascript
// Получение заголовка
const title = window.modalsConfig.getModalTitle('timezoneModal');

// Использование в компоненте
<cmp-modal
    modal-id="timezoneModal"
    :title="modalsConfig?.getModalTitle('timezoneModal')">
</cmp-modal>

// Использование в меню
<dropdown-menu-item
    :title="modalsConfig?.getModalTitle('timezoneModal')"
    @click="openTimezoneModal">
</dropdown-menu-item>
```

### Правила

1. **Всегда используйте `modalsConfig.getModalTitle()`** для получения заголовка модального окна
2. **Не дублируйте заголовки** в разных местах - используйте конфигурацию
3. **При добавлении нового модального окна** обязательно добавьте его в `modals-config.js`
4. **Статические примеры** должны использовать ту же конфигурацию, что и рабочие модальные окна
5. **Проверяйте синхронизацию** при изменении заголовка - обновляется ли он везде

### Преимущества

- **Единый источник правды:** изменение в одном месте синхронизируется везде
- **Автоматическая валидация:** можно проверить соответствие заголовков
- **Упрощение поддержки:** не нужно искать все места использования
- **Расширяемость:** легко добавлять новые метаданные (иконки, описания)

### Компонент cmp-modal

Компонент `cmp-modal` поддерживает prop `title`:
- Если `title` передан - используется он
- Если `title` не передан - автоматически получается из `modalsConfig` по `modalId`
- Заголовок доступен через `modalApi.title` для компонентов внутри модального окна

### ССЫЛКИ

- Конфигурация модальных окон: `core/config/modals-config.js`
- Компонент модального окна: `shared/components/modal.js`

